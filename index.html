<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>æ™¯é»å°„æ“Šå°éŠæˆ²ï¼ˆå¯æ›çœŸå¯¦èƒŒæ™¯ï¼‰</title>
  <style>
    :root { font-family: system-ui, -apple-system, "Noto Sans TC", Segoe UI, Roboto, Arial; }
    body { margin:0; background:#0b0c10; color:#fff; overflow:hidden; }
    #ui {
      position:fixed; top:10px; left:10px; right:10px;
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      pointer-events:none;
    }
    .chip {
      pointer-events:auto;
      background: rgba(20,22,34,.78);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 8px 12px;
      font-weight: 800;
      font-size: 13px;
      backdrop-filter: blur(8px);
    }
    .btn {
      pointer-events:auto;
      cursor:pointer;
      background:#1d2140;
      border: 1px solid rgba(255,255,255,.14);
      color:#fff;
      border-radius: 999px;
      padding: 8px 12px;
      font-weight: 900;
      font-size: 13px;
    }
    .hint {
      pointer-events:auto;
      font-size:12px; opacity:.85; line-height:1.6;
      background: rgba(20,22,34,.78);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 10px 12px;
      max-width: 520px;
      backdrop-filter: blur(8px);
    }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="ui">
    <div class="chip">åˆ†æ•¸ï¼š<span id="score">0</span>ã€€ç”Ÿå‘½ï¼š<span id="hp">3</span>ã€€é€£æ“Šï¼š<span id="combo">0</span></div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button class="btn" id="pauseBtn">æš«åœ</button>
      <button class="btn" id="restartBtn">é‡ä¾†</button>
    </div>
    <div class="hint">
      âœ… æ‰‹æ©Ÿï¼šé»ä¸€ä¸‹ç•«é¢å°±å°„æ“Šï¼ˆæœæº–æ˜Ÿæ–¹å‘ï¼‰<br/>
      âœ… æ¡Œæ©Ÿï¼šæ»‘é¼ ç§»å‹•ï¼æº–æ˜Ÿï¼›é»æ“Šï¼å°„æ“Š<br/>
      ğŸ“· èƒŒæ™¯ï¼šæŠŠä½ çš„æ™¯é»çœŸå¯¦ç…§ç‰‡å‘½åç‚º <b>bg.jpg</b> æ”¾åŒä¸€è³‡æ–™å¤¾å³å¯
    </div>
  </div>

  <!-- å¯é¸ï¼šéŸ³æ•ˆï¼ˆæ”¾åŒå±¤å³å¯ï¼›æ²’æœ‰æª”æ¡ˆä¹Ÿä¸æœƒå£ï¼‰ -->
  <audio id="shootSfx" src="shoot.wav" preload="auto"></audio>
  <audio id="hitSfx" src="hit.wav" preload="auto"></audio>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const scoreEl = document.getElementById("score");
  const hpEl = document.getElementById("hp");
  const comboEl = document.getElementById("combo");
  const pauseBtn = document.getElementById("pauseBtn");
  const restartBtn = document.getElementById("restartBtn");
  const shootSfx = document.getElementById("shootSfx");
  const hitSfx = document.getElementById("hitSfx");

  // ====== èƒŒæ™¯ï¼šçœŸå¯¦æ™¯é»ç…§ç‰‡ï¼ˆæ›æˆä½ çš„æª”å/ç¶²å€éƒ½å¯ä»¥ï¼‰ ======
  const bgImg = new Image();
  bgImg.src = "bg.jpg"; // æˆ–æ”¹æˆå®Œæ•´ç¶²å€
  let bgReady = false;
  bgImg.onload = () => bgReady = true;

  // ====== éŠæˆ²åƒæ•¸ï¼ˆå¯å¾®èª¿ï¼‰ ======
  const config = {
    targetSpawnMs: 650,      // ç›®æ¨™ç”Ÿæˆé–“éš”ï¼ˆè¶Šå°è¶Šé›£ï¼‰
    targetSpeedMin: 40,
    targetSpeedMax: 110,
    bulletSpeed: 720,
    targetRadius: 22,
    bulletRadius: 5,
    maxTargets: 10,
    hp: 3,
    // èƒŒæ™¯é¡¯ç¤ºæ–¹å¼ï¼šcoverï¼ˆè£åˆ‡é‹ªæ»¿ï¼‰ or containï¼ˆå®Œæ•´ä½†å¯èƒ½ç•™é»‘é‚Šï¼‰
    bgMode: "cover",
  };

  // ====== ç‹€æ…‹ ======
  let W = 0, H = 0, DPR = 1;
  let running = true;
  let lastT = performance.now();
  let lastSpawn = 0;

  let score = 0;
  let hp = config.hp;
  let combo = 0;

  const player = { x: 0, y: 0 }; // æº–æ˜Ÿä½ç½®
  const bullets = [];
  const targets = [];
  const particles = [];

  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    player.x = W * 0.5;
    player.y = H * 0.65;
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  // ====== è¼”åŠ©ï¼šèƒŒæ™¯ cover/contain ç¹ªè£½ ======
  function drawBackground() {
    if (!bgReady) {
      // èƒŒæ™¯å°šæœªè¼‰å…¥ï¼šç”¨æ¼¸å±¤æ›¿ä»£
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, "#0b0c10");
      g.addColorStop(1, "#141622");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);
      return;
    }

    const iw = bgImg.naturalWidth, ih = bgImg.naturalHeight;
    if (!iw || !ih) return;

    const sx = 0, sy = 0;
    let sw = iw, sh = ih;
    let dx = 0, dy = 0, dw = W, dh = H;

    const ir = iw / ih;
    const cr = W / H;

    if (config.bgMode === "cover") {
      // è£åˆ‡é‹ªæ»¿
      if (ir > cr) {
        // åœ–å¤ªå¯¬ï¼Œè£å·¦å³
        sh = ih;
        sw = Math.floor(ih * cr);
        const cut = Math.floor((iw - sw) / 2);
        ctx.drawImage(bgImg, cut, 0, sw, sh, 0, 0, W, H);
      } else {
        // åœ–å¤ªé«˜ï¼Œè£ä¸Šä¸‹
        sw = iw;
        sh = Math.floor(iw / cr);
        const cut = Math.floor((ih - sh) / 2);
        ctx.drawImage(bgImg, 0, cut, sw, sh, 0, 0, W, H);
      }
    } else {
      // containï¼šå®Œæ•´é¡¯ç¤ºï¼Œå¯èƒ½ç•™é»‘é‚Š
      if (ir > cr) {
        dw = W;
        dh = Math.floor(W / ir);
        dx = 0;
        dy = Math.floor((H - dh) / 2);
      } else {
        dh = H;
        dw = Math.floor(H * ir);
        dy = 0;
        dx = Math.floor((W - dw) / 2);
      }
      ctx.fillStyle = "#0b0c10";
      ctx.fillRect(0, 0, W, H);
      ctx.drawImage(bgImg, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    // è¼•å¾®æš—è§’è®“ç›®æ¨™æ›´æ¸…æ¥š
    const vg = ctx.createRadialGradient(W*0.5, H*0.5, Math.min(W,H)*0.1, W*0.5, H*0.5, Math.max(W,H)*0.65);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,0.45)");
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, W, H);
  }

  // ====== ç”Ÿæˆç›®æ¨™ ======
  function spawnTarget() {
    if (targets.length >= config.maxTargets) return;

    const side = Math.floor(Math.random() * 3); // 0:ä¸Š, 1:å·¦, 2:å³
    let x, y, vx, vy;

    const speed = rand(config.targetSpeedMin, config.targetSpeedMax);
    if (side === 0) {
      x = rand(30, W - 30); y = -30;
      vx = rand(-30, 30); vy = speed;
    } else if (side === 1) {
      x = -30; y = rand(60, H * 0.6);
      vx = speed; vy = rand(-20, 40);
    } else {
      x = W + 30; y = rand(60, H * 0.6);
      vx = -speed; vy = rand(-20, 40);
    }

    targets.push({
      x, y, vx, vy,
      r: config.targetRadius,
      hp: 1,
      t: 0,
    });
  }

  // ====== å°„æ“Š ======
  function shoot(tx, ty) {
    if (!running) return;
    // éŸ³æ•ˆï¼ˆè‹¥æª”æ¡ˆä¸å­˜åœ¨ï¼Œcatch ä¹Ÿæ²’äº‹ï¼‰
    try { shootSfx.currentTime = 0; shootSfx.play().catch(()=>{}); } catch(e){}

    const x = player.x, y = player.y;
    const dx = tx - x, dy = ty - y;
    const len = Math.hypot(dx, dy) || 1;
    const vx = (dx / len) * config.bulletSpeed;
    const vy = (dy / len) * config.bulletSpeed;

    bullets.push({ x, y, vx, vy, r: config.bulletRadius, life: 1.1 });
  }

  // ====== ç¢°æ’ ======
  function hitTestCircle(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    const rr = a.r + b.r;
    return (dx*dx + dy*dy) <= rr*rr;
  }

  // ====== ç²’å­ ======
  function boom(x, y) {
    for (let i = 0; i < 14; i++) {
      const ang = rand(0, Math.PI * 2);
      const sp = rand(80, 260);
      particles.push({
        x, y,
        vx: Math.cos(ang) * sp,
        vy: Math.sin(ang) * sp,
        life: rand(0.25, 0.6),
      });
    }
  }

  // ====== æ›´æ–°/ç¹ªè£½ ======
  function update(dt) {
    // ç”Ÿæˆç›®æ¨™
    lastSpawn += dt * 1000;
    if (lastSpawn >= config.targetSpawnMs) {
      lastSpawn = 0;
      spawnTarget();
    }

    // å­å½ˆ
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;
      if (b.life <= 0 || b.x < -50 || b.x > W+50 || b.y < -50 || b.y > H+50) {
        bullets.splice(i, 1);
      }
    }

    // ç›®æ¨™
    for (let i = targets.length - 1; i >= 0; i--) {
      const t = targets[i];
      t.t += dt;
      t.x += t.vx * dt;
      t.y += t.vy * dt;

      // ç›®æ¨™æ‰åˆ°ä¸‹æ–¹ç®—å¤±èª¤æ‰£è¡€
      if (t.y > H + 60) {
        targets.splice(i, 1);
        combo = 0;
        hp -= 1;
        if (hp <= 0) gameOver();
      }
    }

    // ç¢°æ’ï¼šå­å½ˆ vs ç›®æ¨™
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      for (let j = targets.length - 1; j >= 0; j--) {
        const t = targets[j];
        if (hitTestCircle(b, t)) {
          bullets.splice(i, 1);
          targets.splice(j, 1);
          combo += 1;
          score += 10 + Math.min(20, combo * 2);
          boom(t.x, t.y);
          try { hitSfx.currentTime = 0; hitSfx.play().catch(()=>{}); } catch(e){}
          break;
        }
      }
    }

    // ç²’å­
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= Math.pow(0.05, dt);
      p.vy *= Math.pow(0.05, dt);
      p.life -= dt;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // UI
    scoreEl.textContent = String(score);
    hpEl.textContent = String(hp);
    comboEl.textContent = String(combo);
  }

  function draw() {
    drawBackground();

    // ç›®æ¨™
    for (const t of targets) {
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255, 230, 0, 0.92)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.stroke();
    }

    // å­å½ˆ
    for (const b of bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fill();
    }

    // ç²’å­
    for (const p of particles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255, 255, 255, 0.75)";
      ctx.fill();
    }

    // æº–æ˜Ÿ
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 18, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-24, 0); ctx.lineTo(-8, 0);
    ctx.moveTo(8, 0); ctx.lineTo(24, 0);
    ctx.moveTo(0, -24); ctx.lineTo(0, -8);
    ctx.moveTo(0, 8); ctx.lineTo(0, 24);
    ctx.stroke();
    ctx.restore();

    if (!running) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = "#fff";
      ctx.font = "900 28px system-ui";
      ctx.fillText("éŠæˆ²çµæŸ", 24, 56);
      ctx.font = "700 16px system-ui";
      ctx.fillText(`åˆ†æ•¸ï¼š${score}ï¼ˆé»ã€Œé‡ä¾†ã€å†ç©ä¸€æ¬¡ï¼‰`, 24, 84);
    }
  }

  function loop(now) {
    const dt = Math.min(0.033, (now - lastT) / 1000);
    lastT = now;

    if (running) update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  function gameOver() {
    running = false;
    pauseBtn.textContent = "ç¹¼çºŒ";
  }

  function restart() {
    score = 0;
    hp = config.hp;
    combo = 0;
    bullets.length = 0;
    targets.length = 0;
    particles.length = 0;
    running = true;
    pauseBtn.textContent = "æš«åœ";
  }

  function rand(a, b){ return a + Math.random() * (b - a); }

  // ====== æ“ä½œï¼ˆæ»‘é¼ /è§¸æ§ï¼‰ ======
  function setAim(clientX, clientY) {
    player.x = Math.max(0, Math.min(W, clientX));
    player.y = Math.max(0, Math.min(H, clientY));
  }

  canvas.addEventListener("mousemove", (e) => setAim(e.clientX, e.clientY), { passive:true });
  canvas.addEventListener("click", (e) => { setAim(e.clientX, e.clientY); shoot(e.clientX, e.clientY); });

  canvas.addEventListener("touchstart", (e) => {
    const t = e.touches[0];
    if (!t) return;
    setAim(t.clientX, t.clientY);
    shoot(t.clientX, t.clientY);
  }, { passive:true });

  canvas.addEventListener("touchmove", (e) => {
    const t = e.touches[0];
    if (!t) return;
    setAim(t.clientX, t.clientY);
  }, { passive:true });

  // ====== UI Buttons ======
  pauseBtn.addEventListener("click", () => {
    running = !running;
    pauseBtn.textContent = running ? "æš«åœ" : "ç¹¼çºŒ";
  });
  restartBtn.addEventListener("click", restart);

  // ====== å•Ÿå‹• ======
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
